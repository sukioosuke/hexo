{"meta":{"title":"Suki's Blog","subtitle":null,"description":null,"author":"Suki","url":"https://sukioosuke.github.io"},"posts":[{"title":"统计学概论","slug":"statistics-introduction","date":"2019-07-04T13:56:25.000Z","updated":"2019-07-15T15:14:14.729Z","comments":true,"path":"2019/07/04/statistics-introduction/","link":"","permalink":"https://sukioosuke.github.io/2019/07/04/statistics-introduction/","excerpt":"","text":"统计学习是关于计算机基于数据构建概率统计模型并用模型对数据进行预测与分析的一门学科。统计学习方法是由模型、策略和算法构成的。 $$ 方法 = 模型 + 策略 + 算法 $$ 模型####1.非概率模型在非概率模型中，假设空间F是由一个参数向量决定的函数族。X、Y分别代表输入空间和输出空间，θ为参数空间。$$ \\mathcal{F}={f|Y=f_\\theta(X),\\theta\\in\\mathrm{R}^n} $$ ####2.概率模型在概率模型中，假设空间F是由一个参数向量决定的条件概率分布族。X、Y分别代表输入空间和输出空间，θ为参数空间。$$ \\mathcal{F}={P|P_\\theta(Y|X),\\theta\\in\\mathrm{R}^n} $$ 策略####1.损失函数和风险函数常用的损失函数（代价函数）有以下几种： 0-1损失函数（0-1 loss function）$$ L(Y,f(X))=\\begin{cases}1, Y\\not=f(X)\\0, Y=f(X)\\\\end{cases} $$ 平方损失函数（quadratic loss function）$$ L(Y,f(X))=(Y-f(X))^2 $$ 绝对损失函数（absolute loss function）$$ L(Y,f(X))=|Y-f(X)| $$ 对数损失函数（logarithmic loss function）（对数似然损失函数）$$ L(Y,P(Y|X))=-logP(Y|X) $$ 损失函数的期望即风险函数，模型f(X)关于联合分布P(X,Y)的平均意义下的损失。$$ R_{exp}(f)=E_P[L(Y,f(X))]=\\int_{\\mathcal{X}\\times\\mathcal{Y}}L(y,f(x))P(x,y)dxdy $$学习的目标就是选择期望风险最小的模型，但P(X,Y)是未知的，故$R_{exp}(f)$不能直接计算。从而对训练数据集计算经验损失$R_{emp}(f)$:$$ R_{emp}(f)=1/N\\sum_{i=1}^{N}L(y_i,f(x_i)) $$在N趋于无穷是，$R_{emp}(f)$趋近于$R_{exp}(f)$。但是实验中训练样本数有限，所以要对经验风险进行一定的矫正，在矫正总有两个基本策略：①经验风险最小化和②结构风险最小化。 ####2.经验风险最小化和结构风险最小化 #####1)经验风险最小化（ERM）经验风险最小化的策略认为，经验风险最小的模型就是最优的模型。根据这一策略，可转化为求解最优化问题：$$ \\min_{f\\in\\mathcal{F}} \\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i)) $$但是当样本容量很小时，经验风险最小化学习就可能会出现过拟合现象。 #####2)结构风险最小化（SRM）结构风险最小化等价于正则化，有效的防止了过拟合。结构风险在经验风险上加上表示模型复杂度的正则化项或者罚项。结构风险的定义为：$$ R_{srm}(f)=\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i))+\\lamdaJ(f) $$J(f)表示模型的复杂度，$/lamda$是系数，用于权衡经验风险和模型复杂度。即求最优模型，就是求解最优化问题$\\min_f\\in\\mathcal{F} R_{srm}F$ 算法算法是指学习模型的具体计算方法。统计学习的问题是最优化问题，统计学习算法也就是求解最优化问题的算法。要找到全局最优解，并且求解过程要高效。","raw":null,"content":null,"categories":[{"name":"统计学","slug":"统计学","permalink":"https://sukioosuke.github.io/categories/统计学/"}],"tags":[{"name":"统计学","slug":"统计学","permalink":"https://sukioosuke.github.io/tags/统计学/"},{"name":"损失函数","slug":"损失函数","permalink":"https://sukioosuke.github.io/tags/损失函数/"},{"name":"代价函数","slug":"代价函数","permalink":"https://sukioosuke.github.io/tags/代价函数/"}]},{"title":"python中的yield关键字","slug":"python-yield","date":"2019-07-02T08:47:06.000Z","updated":"2019-07-04T13:53:52.368Z","comments":true,"path":"2019/07/02/python-yield/","link":"","permalink":"https://sukioosuke.github.io/2019/07/02/python-yield/","excerpt":"","text":"今天在看别人的代码时遇到了yield关键字，当时学python的时候学的并不扎实，现在做个总结 yield example一个网上经常列举的yield的例子： 12345def node._get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist &lt; self._median: yield self._leftchild if self._rightchild and distance + max_dist &gt;= self._median: yield self._rightchild 下面是具体调用时的执行 12345678result, candidates = list(), [self]while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance &lt;= max_dist and distance &gt;= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))return result 调用_get_child_candidates时，返回了一个child的合集（list），yield是如何生成这个对象的呢？ 先来看一下可迭代对象当你建立了一个列表，你可以逐项地读取这个列表，这叫做一个可迭代对象: 123456&gt;&gt;&gt; mylist = [1, 2, 3]&gt;&gt;&gt; for i in mylist :... print(i)123 mylist是一个可迭代的对象。当你使用一个列表生成式来建立一个列表的时候，同样生成了一个可迭代的对象: 123456&gt;&gt;&gt; mylist = [x for x in range(3)]&gt;&gt;&gt; for i in mylist :... print(i)012 可以通过for循环读取的对象就是一个迭代器，其元素在遍历访问时均存储在了内存中，如果要大量访问数据的话，迭代器的方式是很占用资源的 生成器生成器是可以迭代的对象，但是你只需读取一次，它可以在调用时实时生成数据，而不是将数据都存放在内存中。 123456&gt;&gt;&gt; mygenerator = (x for x in range(3))&gt;&gt;&gt; for i in mygenerator :... print(i)012 虽然只是把(换成了[，但是对于生成器而言，只能迭代一次，而且也从迭代器变成了生成器。 回到yield关键字yield关键字在调用后会返回一个类似于mygenerator的生成器，类似于返回生成器的return关键字。 12345678910111213&gt;&gt;&gt; def createGenerator() :... mylist = range(3)... for i in mylist :... yield i*i...&gt;&gt;&gt; mygenerator = createGenerator() # create a generator&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!&lt;generator object createGenerator at 0xb7555c34&gt;&gt;&gt;&gt; for i in mygenerator:... print(i)014 在执行for i in mygenerator时，到达yield关键字时，返回yield后的值作为第一次迭代的返回值. 然后，每次执行这个函数都会继续返回定义的迭代值，直到没有可以返回的。带有yield的函数不仅仅只用于for循环中，而且可用于某个函数的参数，只要这个函数的参数允许迭代参数。比如array.extend函数，它的原型是array.extend(iterable)。 此处应注意的是，生成器的方法虽然可以调用多次，获取多个迭代结果，但生成器只会实例化一次，既实例化后的生成器可以通过变量等来控制生成器的生成与穷尽。可参考如下代码： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs... crisis = False... def create_atm(self) :... while not self.crisis :... yield \"$100\"&gt;&gt;&gt; hsbc = Bank() # when everything's ok the ATM gives you as much as you want&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print(corner_street_atm.__next__()())$100&gt;&gt;&gt; print([corner_street_atm.__next__()() for cash in range(5)])['$100', '$100', '$100', '$100', '$100']&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money!&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # it's even true for new ATMs&gt;&gt;&gt; print(wall_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty&gt;&gt;&gt; print(corner_street_atm.__next__()())&lt;type 'exceptions.StopIteration'&gt;&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # build a new one to get back in business&gt;&gt;&gt; for cash in brand_new_atm :... print cash$100$100$100$100$100$100$100$100$100... 迭代器的操作生成器只能实例化一次，这就为我们的复用造成一些麻烦，如果需要两个一模一样但是相互独立的生成器怎么办呢？itertools提供了很多特殊的迭代方法，包括复制一个迭代器，串联迭代器，把嵌套的列表分组等等等，这个类从一定程度上解决了生成器的复用问题。如果想要动态变化生成器的内容呢？生成器本身除去next方法外，还有一个send(msg)的方法，send(msg)与next()的区别在于send可以传递参数给yield表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。比如函数中有一个yield赋值，a = yield 5，第一次迭代到这里会返回5，a还没有赋值。第二次迭代时，使用.send(10)，那么，就是强行修改yield 5表达式的值为10，本来是5的，而现在a=10。可以认为，next()等同于send(None)。 此处应注意的是，第一次调用时必须先next()或send(None)，否则会报错，因为这时候没有上一个yield值。 关于迭代器的内部原理迭代是一个实现可迭代对象(实现的是__iter__()方法)和迭代器(实现的是__next__()方法)的过程。可迭代对象是你可以从其获取到一个迭代器的任一对象。迭代器是那些允许你迭代可迭代对象的对象。 参考文献：https://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html#yield","raw":null,"content":null,"categories":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sukioosuke.github.io/tags/python/"}]},{"title":"Hello World!","slug":"Hello-World","date":"2019-06-25T09:39:24.000Z","updated":"2019-07-15T15:14:16.867Z","comments":true,"path":"2019/06/25/Hello-World/","link":"","permalink":"https://sukioosuke.github.io/2019/06/25/Hello-World/","excerpt":"","text":"之前一直想找个工具记录一下自己的所学所想，开始在csdn做简单的记录，后来改版后每次写的时候都要花费不少功夫要写，就慢慢放弃了。这次在git用hexo自建blog，可以避免这个问题，也可以让自己坚持下去。blog主要用于： 整理知识，学习笔记 发布日记，杂文，所见所想 整理技术文稿（代码） 别人的赏识都是过眼云烟，只有自己的提高进步才是真金白银！ p.s. 在线md编写工具 LaTex符号","raw":null,"content":null,"categories":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://sukioosuke.github.io/tags/随笔/"}]}]}